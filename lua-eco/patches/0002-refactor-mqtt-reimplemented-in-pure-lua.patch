From c658b667aae664b2ec23b9082be88b439e4eee2f Mon Sep 17 00:00:00 2001
From: Jianhui Zhao <zhaojh329@gmail.com>
Date: Sat, 20 Apr 2024 17:45:34 +0800
Subject: [PATCH] refactor(mqtt): reimplemented in pure lua

Signed-off-by: Jianhui Zhao <zhaojh329@gmail.com>
---
 CMakeLists.txt     |  25 +-
 README.md          |   3 +-
 README_ZH.md       |   3 +-
 examples/mqtt.lua  |  95 +++---
 mqtt.c             | 589 ------------------------------------
 mqtt.lua           | 735 +++++++++++++++++++++++++++++++++++++++++----
 tests/mqtt_pub.lua |  63 ++--
 tests/mqtt_sub.lua |  36 ++-
 8 files changed, 787 insertions(+), 762 deletions(-)
 delete mode 100644 mqtt.c

diff --git a/CMakeLists.txt b/CMakeLists.txt
index d2209c0..027833c 100644
--- a/CMakeLists.txt
+++ b/CMakeLists.txt
@@ -134,29 +134,6 @@ if (ECO_UBUS_SUPPORT)
     endif()
 endif()
 
-if (ECO_MQTT_SUPPORT)
-    find_path(MOSQ_INCLUDE_DIRS mosquitto.h)
-    find_library(MOSQ NAMES mosquitto)
-    if (MOSQ_INCLUDE_DIRS AND MOSQ)
-        add_library(mqtt MODULE mqtt.c)
-        target_include_directories(mqtt PRIVATE ${MOSQ_INCLUDE_DIRS})
-        target_link_libraries(mqtt PRIVATE ${MOSQ})
-        set_target_properties(mqtt PROPERTIES OUTPUT_NAME mqtt PREFIX "")
-
-        install(
-            TARGETS mqtt
-            DESTINATION ${LUA_INSTALL_PREFIX}/eco/core
-        )
-
-        install(
-            FILES mqtt.lua
-            DESTINATION ${LUA_INSTALL_PREFIX}/eco
-        )
-    else()
-        message(WARNING "Not found libmosquitto. Skip build eco.mqtt")
-    endif()
-endif()
-
 if (ECO_SSH_SUPPORT)
     pkg_search_module(LIBSSH2 libssh2)
     if (LIBSSH2_FOUND)
@@ -214,7 +191,7 @@ install(
 )
 
 install(
-    FILES time.lua sys.lua file.lua dns.lua socket.lua
+    FILES time.lua sys.lua file.lua dns.lua socket.lua mqtt.lua
         websocket.lua sync.lua nl.lua genl.lua ip.lua nl80211.lua
     DESTINATION ${LUA_INSTALL_PREFIX}/eco
 )
diff --git a/README.md b/README.md
index 24d9b1a..f88d091 100644
--- a/README.md
+++ b/README.md
@@ -19,7 +19,6 @@
 
 [lua]: https://www.lua.org
 [libev]: http://software.schmorp.de/pkg/libev.html
-[libmosquitto]: https://github.com/eclipse/mosquitto
 [ubus]: https://openwrt.org/docs/techref/ubus
 
 Lua-eco is a Lua interpreter with a built-in event loop for scheduling lightweight coroutines automatically, enabling efficient concurrency in Lua. Build high-performance, scalable applications.
@@ -34,7 +33,7 @@ Lua-eco also provides some modules for you to build applications quickly:
 * `ssl`: Provides SSL/TLS support for Lua-eco applications, allowing you to establish secure connections to remote servers.
 * `http/https`: Provides a HTTP client and server implementation for Lua-eco applications.
 * `websocket`: Provides a WebSocket client and server implementation for Lua-eco applications, allowing you to build real-time web applications.
-* `mqtt`: Provides an implementation of the MQTT protocol for Lua-eco applications binding [libmosquitto], allowing you to build IoT and messaging applications.
+* `mqtt`: Provides an implementation of the MQTT 3.1.1 protocol for Lua-eco applications.
 * `dns`: Provides a DNS client implementation for Lua-eco applications, allowing you to perform DNS lookups and resolve domain names.
 * `ubus`: Provides a Lua interface to the [ubus] system in OpenWrt, allowing you to interact with system services and daemons.
 * `sync`: Provides operations for synchronization between coroutines.
diff --git a/README_ZH.md b/README_ZH.md
index a294d5c..d535a70 100644
--- a/README_ZH.md
+++ b/README_ZH.md
@@ -22,7 +22,6 @@
 
 [lua]: https://www.lua.org
 [libev]: http://software.schmorp.de/pkg/libev.html
-[lua-mosquitto]: https://github.com/flukso/lua-mosquitto
 [ubus]: https://openwrt.org/docs/techref/ubus
 
 Lua-eco 是一个内置了事件循环的 Lua 解释器。它能够自动调度轻量级 `Lua 协程`, 从而实现在 Lua 中的高效并发。使用 Lua-eco 可以构建高性能、可扩展的应用程序。
@@ -37,7 +36,7 @@ Lua-eco 还提供了一些有用的模块，方便您快速构建应用程序:
 * `ssl`: 为 Lua-eco 应用程序提供了 SSL/TLS 支持，允许您建立与远程服务器的安全连接。
 * `http/https`: 为 Lua-eco 应用程序提供了 HTTP(S) 客户端和服务器实现。
 * `websocket`: 为 Lua-eco 应用程序提供了一个 WebSocket 客户端和服务器实现，允许您构建实时 Web 应用程序。
-* `mqtt`: 提供了一个 MQTT 协议的 Lua-eco 实现，使用 [lua-mosquitto]，允许您构建物联网和消息应用程序。
+* `mqtt`: 为 Lua-eco 应用程序提供了一个 MQTT 3.1.1 协议的实现。
 * `dns`: 为 Lua-eco 应用程序提供了一个 DNS 客户端实现，允许您执行 DNS 查找和解析域名。
 * `ubus`: 提供了一个 Lua 接口，用于 OpenWrt 中的 [ubus] 系统，允许您与系统服务和守护程序交互。
 * `sync`: 提供了协程间同步的操作。
diff --git a/examples/mqtt.lua b/examples/mqtt.lua
index e07ad12..db9ec23 100755
--- a/examples/mqtt.lua
+++ b/examples/mqtt.lua
@@ -1,67 +1,74 @@
 #!/usr/bin/env eco
 
+-- Using emqx for testing
+-- docker run -d --name emqx -p 1883:1883 -p 8083:8083 -p 8084:8084 -p 8883:8883 -p 18083:18083 emqx/emqx:latest
+
 local mqtt = require 'eco.mqtt'
 local time = require 'eco.time'
-local log = require 'eco.log'
 
-local auto_reconnect = true
+local auto_reconnect = false
 
-local function reconnect(con)
-    while true do
-        local ok, err = con:connect('localhost', 1883)
-        if ok then return end
+local function on_conack(ack, client)
+    print('conack:', ack.rc, ack.reason, ack.session_present)
 
-        log.err('connect fail:', err)
+    if ack.rc ~= mqtt.CONNACK_ACCEPTED then
+        return
+    end
 
-        if not auto_reconnect then return end
+    client:subscribe('test', mqtt.QOS2)
 
-        log.err('reconnect in 5s...')
-        time.sleep(5)
-    end
+    client:publish('eco', 'I am lua-eco MQTT', mqtt.QOS2)
 end
 
-local con = mqtt.new('eco-' .. os.time())
-
-con:set_callback('ON_CONNECT', function(success, rc, str)
-    log.info('ON_CONNECT:', success, rc, str)
+local function on_suback(ack)
+    if ack.rc == mqtt.SUBACK_FAILURE then
+        print('suback:', ack.topic, 'fail')
+    else
+        print('suback:', ack.topic, ack.rc)
+    end
+end
 
-    con:subscribe('$SYS/#')
-    con:subscribe('eco', 2)
+local function on_unsuback(topic)
+    print('unsuback:', topic)
+end
 
-    con:publish('world', 'hello')
-end)
+local function on_publish(msg, client)
+    print('message:', msg.topic, msg.payload)
+    client:unsubscribe('test')
+end
 
-con:set_callback('ON_DISCONNECT', function(success, rc, str)
-    log.info('ON_DISCONNECT:', success, rc, str)
+local function on_error(err)
+    print('error:', err)
+end
 
-    if auto_reconnect then
-        time.sleep(5)
-        reconnect(con)
-    end
-end)
+local client = mqtt.new({
+    ipaddr = '127.0.0.1',
+    clean_session = true
+})
 
-con:set_callback('ON_PUBLISH', function(mid)
-    log.info('ON_PUBLISH:', mid)
-end)
+-- And you can set an option individually
+client:set('keepalive', 5.0)
 
-con:set_callback('ON_MESSAGE', function(mid, topic, payload, qos, retain)
-    log.info('ON_MESSAGE:', mid, topic, payload, qos, retain)
-end)
+-- You can add multiple event handlers at once
+client:on({
+    conack = on_conack,
+    suback = on_suback,
+    unsuback = on_unsuback,
+    publish = on_publish
+})
 
-con:set_callback('ON_SUBSCRIBE', function(...)
-    log.info('ON_SUBSCRIBE:', ...)
-end)
+-- Or add one event handler at a time
+client:on('error', on_error)
 
-con:set_callback('ON_UNSUBSCRIBE', function(mid)
-    log.info('ON_UNSUBSCRIBE:', mid)
-end)
+while true do
+    -- Start handling events until the network connection is closed
+    client:run()
 
-con:set_callback('ON_LOG', function(level, str)
-    log.info('ON_LOG:', level, str)
-end)
+    if not auto_reconnect then
+        break
+    end
 
-reconnect(con)
+    print('reconnect in 5s...')
 
-while true do
-    time.sleep(1)
+    time.sleep(5)
 end
diff --git a/mqtt.c b/mqtt.c
deleted file mode 100644
index 4639cdd..0000000
--- a/mqtt.c
+++ /dev/null
@@ -1,589 +0,0 @@
-/* SPDX-License-Identifier: MIT */
-/*
- * Author: Jianhui Zhao <zhaojh329@gmail.com>
- *
- */
-
-#include <mosquitto.h>
-#include <string.h>
-#include <errno.h>
-#include <fcntl.h>
-
-#include "eco.h"
-
-enum connect_return_codes {
-    CONN_ACCEPT,
-    CONN_REF_BAD_PROTOCOL,
-    CONN_REF_BAD_ID,
-    CONN_REF_SERVER_NOAVAIL,
-    CONN_REF_BAD_LOGIN,
-    CONN_REF_NO_AUTH,
-    CONN_REF_BAD_TLS
-};
-
-#define ECO_MQTT_CTX_MT	"eco.mqtt"
-
-struct eco_mqtt_ctx {
-    struct eco_context *eco;
-    struct mosquitto *mosq;
-    struct ev_io ior;
-    struct ev_io iow;
-    struct ev_timer tmr;
-    int on_connect;
-    int on_disconnect;
-    int on_publish;
-    int on_message;
-    int on_subscribe;
-    int on_unsubscribe;
-    int on_log;
-};
-
-static int mosq__pstatus(lua_State *L, int mosq_errno)
-{
-    if (!mosq_errno) {
-        lua_pushboolean(L, true);
-        return 1;
-    }
-
-    lua_pushnil(L);
-    lua_pushstring(L, mosquitto_strerror(mosq_errno));
-    return 2;
-}
-
-static int mosq_version(lua_State *L)
-{
-    int major, minor, rev;
-
-    mosquitto_lib_version(&major, &minor, &rev);
-    lua_pushfstring(L, "%i.%i.%i", major, minor, rev);
-
-    return 1;
-}
-
-static void ctx__on_init(struct eco_mqtt_ctx *ctx)
-{
-    ctx->on_connect = LUA_REFNIL;
-    ctx->on_disconnect = LUA_REFNIL;
-    ctx->on_publish = LUA_REFNIL;
-    ctx->on_message = LUA_REFNIL;
-    ctx->on_subscribe = LUA_REFNIL;
-    ctx->on_unsubscribe = LUA_REFNIL;
-    ctx->on_log = LUA_REFNIL;
-}
-
-static void ctx__on_clear(struct eco_mqtt_ctx *ctx)
-{
-    lua_State *L = ctx->eco->L;
-
-    luaL_unref(L, LUA_REGISTRYINDEX, ctx->on_connect);
-    luaL_unref(L, LUA_REGISTRYINDEX, ctx->on_disconnect);
-    luaL_unref(L, LUA_REGISTRYINDEX, ctx->on_publish);
-    luaL_unref(L, LUA_REGISTRYINDEX, ctx->on_message);
-    luaL_unref(L, LUA_REGISTRYINDEX, ctx->on_subscribe);
-    luaL_unref(L, LUA_REGISTRYINDEX, ctx->on_unsubscribe);
-    luaL_unref(L, LUA_REGISTRYINDEX, ctx->on_log);
-}
-
-static int mosq_new(lua_State *L)
-{
-    const char *id = luaL_optstring(L, 1, NULL);
-    bool clean_session = lua_isboolean(L, 2) ? lua_toboolean(L, 2) : true;
-    struct eco_mqtt_ctx *ctx;
-
-    if (!id && !clean_session)
-        return luaL_argerror(L, 2, "if 'id' is nil then 'clean session' must be true");
-
-    ctx = lua_newuserdata(L, sizeof(struct eco_mqtt_ctx));
-    lua_pushvalue(L, lua_upvalueindex(1));
-    lua_setmetatable(L, -2);
-
-    /* ctx will be passed as void *obj arg in the callback functions */
-    ctx->mosq = mosquitto_new(id, clean_session, ctx);
-
-    if (!ctx->mosq)
-        return luaL_error(L, strerror(errno));
-
-    ctx->eco = eco_get_context(L);
-    ctx__on_init(ctx);
-
-    return 1;
-}
-
-static int ctx_destroy(lua_State *L)
-{
-    struct eco_mqtt_ctx *ctx = luaL_checkudata(L, 1, ECO_MQTT_CTX_MT);
-
-    mosquitto_destroy(ctx->mosq);
-
-    ctx__on_clear(ctx);
-
-    return mosq__pstatus(L, MOSQ_ERR_SUCCESS);
-}
-
-static int ctx_reinitialise(lua_State *L)
-{
-    struct eco_mqtt_ctx *ctx = luaL_checkudata(L, 1, ECO_MQTT_CTX_MT);
-    const char *id = luaL_optstring(L, 1, NULL);
-    bool clean_session = (lua_isboolean(L, 2) ? lua_toboolean(L, 2) : true);
-    int rc;
-
-    if (!id && !clean_session)
-        return luaL_argerror(L, 3, "if 'id' is nil then 'clean session' must be true");
-
-    rc = mosquitto_reinitialise(ctx->mosq, id, clean_session, ctx);
-
-    ctx__on_clear(ctx);
-    ctx__on_init(ctx);
-
-    return mosq__pstatus(L, rc);
-}
-
-static int ctx_will_set(lua_State *L)
-{
-    struct eco_mqtt_ctx *ctx = luaL_checkudata(L, 1, ECO_MQTT_CTX_MT);
-    const char *topic = luaL_checkstring(L, 2);
-    size_t payloadlen = 0;
-    const void *payload = NULL;
-    int qos, rc;
-    bool retain;
-
-    if (!lua_isnil(L, 3))
-        payload = lua_tolstring(L, 3, &payloadlen);
-
-    qos = luaL_optinteger(L, 4, 0);
-    retain = lua_toboolean(L, 5);
-
-    rc = mosquitto_will_set(ctx->mosq, topic, payloadlen, payload, qos, retain);
-    return mosq__pstatus(L, rc);
-}
-
-static int ctx_will_clear(lua_State *L)
-{
-    struct eco_mqtt_ctx *ctx = luaL_checkudata(L, 1, ECO_MQTT_CTX_MT);
-
-    int rc = mosquitto_will_clear(ctx->mosq);
-    return mosq__pstatus(L, rc);
-}
-
-static int ctx_login_set(lua_State *L)
-{
-    struct eco_mqtt_ctx *ctx = luaL_checkudata(L, 1, ECO_MQTT_CTX_MT);
-    const char *username = lua_isnil(L, 2) ? NULL : luaL_checkstring(L, 2);
-    const char *password = lua_isnil(L, 3) ? NULL : luaL_checkstring(L, 3);
-    int rc = mosquitto_username_pw_set(ctx->mosq, username, password);
-    return mosq__pstatus(L, rc);
-}
-
-static int ctx_tls_set(lua_State *L)
-{
-    struct eco_mqtt_ctx *ctx = luaL_checkudata(L, 1, ECO_MQTT_CTX_MT);
-    const char *cafile = luaL_optstring(L, 2, NULL);
-    const char *capath = luaL_optstring(L, 3, NULL);
-    const char *certfile = luaL_optstring(L, 4, NULL);
-    const char *keyfile = luaL_optstring(L, 5, NULL);
-
-    // the last param is a callback to a function that asks for a passphrase for a keyfile
-    // our keyfiles should NOT have a passphrase
-    int rc = mosquitto_tls_set(ctx->mosq, cafile, capath, certfile, keyfile, 0);
-    return mosq__pstatus(L, rc);
-}
-
-static int ctx_tls_insecure_set(lua_State *L)
-{
-    struct eco_mqtt_ctx *ctx = luaL_checkudata(L, 1, ECO_MQTT_CTX_MT);
-    bool value = lua_toboolean(L, 2);
-    int rc = mosquitto_tls_insecure_set(ctx->mosq, value);
-    return mosq__pstatus(L, rc);
-}
-
-static int ctx_tls_psk_set(lua_State *L)
-{
-    struct eco_mqtt_ctx *ctx = luaL_checkudata(L, 1, ECO_MQTT_CTX_MT);
-    const char *psk = luaL_checkstring(L, 2);
-    const char *identity = luaL_checkstring(L, 3);
-    const char *ciphers = luaL_optstring(L, 4, NULL);
-    int rc = mosquitto_tls_psk_set(ctx->mosq, psk, identity, ciphers);
-    return mosq__pstatus(L, rc);
-}
-
-static int ctx_tls_opts_set(lua_State *L)
-{
-    struct eco_mqtt_ctx *ctx = luaL_checkudata(L, 1, ECO_MQTT_CTX_MT);
-    const bool cert_required = lua_toboolean(L, 2);
-    const char *tls_version = luaL_optstring(L, 3, NULL);
-    const char *ciphers = luaL_optstring(L, 4, NULL);
-    int rc = mosquitto_tls_opts_set(ctx->mosq, cert_required ? 1 : 0, tls_version, ciphers);
-    return mosq__pstatus(L, rc);
-}
-
-static int ctx_option(lua_State *L)
-{
-    struct eco_mqtt_ctx *ctx = luaL_checkudata(L, 1, ECO_MQTT_CTX_MT);
-    enum mosq_opt_t option = luaL_checkinteger(L, 2);
-    int type = lua_type(L, 3);
-    int rc;
-
-    if (type == LUA_TNUMBER) {
-        int val = lua_tonumber(L, 3);
-        rc = mosquitto_int_option(ctx->mosq, option, val);
-    } else if (type == LUA_TSTRING) {
-        const char *val = lua_tolstring(L, 3, NULL);
-        rc = mosquitto_string_option(ctx->mosq, option, val);
-    } else {
-        return luaL_argerror(L, 3, "values must be numeric or string");
-    }
-    return mosq__pstatus(L, rc);
-}
-
-static void ev_timer_cb(struct ev_loop *loop, ev_timer *w, int revents)
-{
-    struct eco_mqtt_ctx *ctx = container_of(w, struct eco_mqtt_ctx, tmr);
-
-    mosquitto_loop_misc(ctx->mosq);
-}
-
-static void ev_io_read_cb(struct ev_loop *loop, ev_io *w, int revents)
-{
-    struct eco_mqtt_ctx *ctx = container_of(w, struct eco_mqtt_ctx, ior);
-    int rc = mosquitto_loop_read(ctx->mosq, 1);
-
-    if (rc) {
-        ev_io_stop(loop, w);
-        ev_io_stop(loop, &ctx->iow);
-        ev_timer_stop(loop, &ctx->tmr);
-        return;
-    }
-
-    if (mosquitto_want_write(ctx->mosq))
-        ev_io_start(loop, &ctx->iow);
-}
-
-static void ev_io_write_cb(struct ev_loop *loop, ev_io *w, int revents)
-{
-    struct eco_mqtt_ctx *ctx = container_of(w, struct eco_mqtt_ctx, iow);
-
-    if (!mosquitto_want_write(ctx->mosq)) {
-        ev_io_stop(loop, w);
-        return;
-    }
-
-    mosquitto_loop_write(ctx->mosq, 1);
-}
-
-static int ctx_connect(lua_State *L)
-{
-    struct eco_mqtt_ctx *ctx = luaL_checkudata(L, 1, ECO_MQTT_CTX_MT);
-    const char *host = luaL_optstring(L, 2, "localhost");
-    int port = luaL_optinteger(L, 3, 1883);
-    int keepalive = luaL_optinteger(L, 4, 60);
-    int rc =  mosquitto_connect_async(ctx->mosq, host, port, keepalive);
-
-    if (rc == MOSQ_ERR_SUCCESS) {
-        int sock = mosquitto_socket(ctx->mosq);
-
-        fcntl(sock, F_SETFL, fcntl(sock, F_GETFL, 0) | O_NONBLOCK);
-
-        ev_timer_init(&ctx->tmr, ev_timer_cb, 3.0, 3.0);
-        ev_timer_start(ctx->eco->loop, &ctx->tmr);
-
-        ev_io_init(&ctx->ior, ev_io_read_cb, sock, EV_READ);
-        ev_io_start(ctx->eco->loop, &ctx->ior);
-
-        ev_io_init(&ctx->iow, ev_io_write_cb, sock, EV_WRITE);
-        ev_io_start(ctx->eco->loop, &ctx->iow);
-    }
-
-    return mosq__pstatus(L, rc);
-}
-
-static int ctx_disconnect(lua_State *L)
-{
-    struct eco_mqtt_ctx *ctx = luaL_checkudata(L, 1, ECO_MQTT_CTX_MT);
-    int rc = mosquitto_disconnect(ctx->mosq);
-    ev_io_start(ctx->eco->loop, &ctx->iow);
-    return mosq__pstatus(L, rc);
-}
-
-static int ctx_publish(lua_State *L)
-{
-    struct eco_mqtt_ctx *ctx = luaL_checkudata(L, 1, ECO_MQTT_CTX_MT);
-    const char *topic = luaL_checkstring(L, 2);
-    size_t payloadlen = 0;
-    const void *payload = NULL;
-    int mid;	/* message id is referenced in the publish callback */
-    int qos, rc;
-    bool retain;
-
-    if (!lua_isnil(L, 3))
-        payload = lua_tolstring(L, 3, &payloadlen);
-
-    qos = luaL_optinteger(L, 4, 0);
-    retain = lua_toboolean(L, 5);
-
-    rc = mosquitto_publish(ctx->mosq, &mid, topic, payloadlen, payload, qos, retain);
-
-    if (rc != MOSQ_ERR_SUCCESS)
-        return mosq__pstatus(L, rc);
-
-    ev_io_start(ctx->eco->loop, &ctx->iow);
-    lua_pushinteger(L, mid);
-
-    return 1;
-}
-
-static int ctx_subscribe(lua_State *L)
-{
-    struct eco_mqtt_ctx *ctx = luaL_checkudata(L, 1, ECO_MQTT_CTX_MT);
-    const char *sub = luaL_checkstring(L, 2);
-    int qos = luaL_optinteger(L, 3, 0);
-    int rc, mid;
-
-    rc = mosquitto_subscribe(ctx->mosq, &mid, sub, qos);
-
-    if (rc != MOSQ_ERR_SUCCESS)
-        return mosq__pstatus(L, rc);
-
-    ev_io_start(ctx->eco->loop, &ctx->iow);
-    lua_pushinteger(L, mid);
-    return 1;
-}
-
-static int ctx_unsubscribe(lua_State *L)
-{
-    struct eco_mqtt_ctx *ctx = luaL_checkudata(L, 1, ECO_MQTT_CTX_MT);
-    const char *sub = luaL_checkstring(L, 2);
-    int rc, mid;
-
-    rc = mosquitto_unsubscribe(ctx->mosq, &mid, sub);
-
-    if (rc != MOSQ_ERR_SUCCESS)
-        return mosq__pstatus(L, rc);
-
-    ev_io_start(ctx->eco->loop, &ctx->iow);
-    lua_pushinteger(L, mid);
-    return 1;
-}
-
-static void ctx_on_connect(struct mosquitto *mosq, void *obj, int rc)
-{
-    struct eco_mqtt_ctx *ctx = obj;
-    lua_State *L = ctx->eco->L;
-    bool success = false;
-    char *str = "reserved for future use";
-
-    switch(rc) {
-        case CONN_ACCEPT:
-            success = true;
-            str = "connection accepted";
-            break;
-
-        case CONN_REF_BAD_PROTOCOL:
-            str = "connection refused - incorrect protocol version";
-            break;
-
-        case CONN_REF_BAD_ID:
-            str = "connection refused - invalid client identifier";
-            break;
-
-        case CONN_REF_SERVER_NOAVAIL:
-            str = "connection refused - server unavailable";
-            break;
-
-        case CONN_REF_BAD_LOGIN:
-            str = "connection refused - bad username or password";
-            break;
-
-        case CONN_REF_NO_AUTH:
-            str = "connection refused - not authorised";
-            break;
-
-        case CONN_REF_BAD_TLS:
-            str = "connection refused - TLS error";
-            break;
-    }
-
-    lua_rawgeti(L, LUA_REGISTRYINDEX, ctx->on_connect);
-
-    lua_pushboolean(L, success);
-    lua_pushinteger(L, rc);
-    lua_pushstring(L, str);
-
-    lua_call(L, 3, 0);
-}
-
-
-static void ctx_on_disconnect(struct mosquitto *mosq, void *obj, int rc)
-{
-    struct eco_mqtt_ctx *ctx = obj;
-    lua_State *L = ctx->eco->L;
-
-    lua_rawgeti(L, LUA_REGISTRYINDEX, ctx->on_disconnect);
-
-    lua_pushboolean(L, !rc);
-    lua_pushinteger(L, rc);
-    lua_pushstring(L, rc ? mosquitto_strerror(rc) : "");
-
-    lua_call(L, 3, 0);
-}
-
-static void ctx_on_publish(struct mosquitto *mosq, void *obj, int mid)
-{
-    struct eco_mqtt_ctx *ctx = obj;
-    lua_State *L = ctx->eco->L;
-
-    lua_rawgeti(L, LUA_REGISTRYINDEX, ctx->on_publish);
-    lua_pushinteger(L, mid);
-    lua_call(L, 1, 0);
-}
-
-static void ctx_on_message(struct mosquitto *mosq, void *obj,
-        const struct mosquitto_message *msg)
-{
-    struct eco_mqtt_ctx *ctx = obj;
-    lua_State *L = ctx->eco->L;
-
-    lua_rawgeti(ctx->eco->L, LUA_REGISTRYINDEX, ctx->on_message);
-
-    lua_pushinteger(L, msg->mid);
-    lua_pushstring(L, msg->topic);
-    lua_pushlstring(L, msg->payload, msg->payloadlen);
-    lua_pushinteger(L, msg->qos);
-    lua_pushboolean(L, msg->retain);
-
-    lua_call(L, 5, 0);
-}
-
-static void ctx_on_subscribe(struct mosquitto *mosq, void *obj, int mid,
-        int qos_count, const int *granted_qos)
-{
-    struct eco_mqtt_ctx *ctx = obj;
-    lua_State *L = ctx->eco->L;
-    int i;
-
-    lua_rawgeti(L, LUA_REGISTRYINDEX, ctx->on_subscribe);
-    lua_pushinteger(L, mid);
-
-    for (i = 0; i < qos_count; i++)
-        lua_pushinteger(L, granted_qos[i]);
-
-    lua_call(L, qos_count + 1, 0);
-}
-
-static void ctx_on_unsubscribe(struct mosquitto *mosq, void *obj, int mid)
-{
-    struct eco_mqtt_ctx *ctx = obj;
-    lua_State *L = ctx->eco->L;
-
-    lua_rawgeti(L, LUA_REGISTRYINDEX, ctx->on_unsubscribe);
-    lua_pushinteger(L, mid);
-    lua_call(L, 1, 0);
-}
-
-static void ctx_on_log(struct mosquitto *mosq, void *obj, int level, const char *str)
-{
-    struct eco_mqtt_ctx *ctx = obj;
-    lua_State *L = ctx->eco->L;
-
-    lua_rawgeti(L, LUA_REGISTRYINDEX, ctx->on_log);
-
-    lua_pushinteger(L, level);
-    lua_pushstring(L, str);
-
-    lua_call(L, 2, 0);
-}
-
-static int ctx_callback_set(lua_State *L)
-{
-    struct eco_mqtt_ctx *ctx = luaL_checkudata(L, 1, ECO_MQTT_CTX_MT);
-    const char *type = luaL_checkstring(L, 2);
-
-    if (!lua_isfunction(L, 3))
-        return luaL_argerror(L, 3, "expecting a callback function");
-
-    int ref = luaL_ref(L, LUA_REGISTRYINDEX);
-
-    if (!strcmp(type, "ON_CONNECT")) {
-        ctx->on_connect = ref;
-        mosquitto_connect_callback_set(ctx->mosq, ctx_on_connect);
-    } else if (!strcmp(type, "ON_DISCONNECT")) {
-        ctx->on_disconnect = ref;
-        mosquitto_disconnect_callback_set(ctx->mosq, ctx_on_disconnect);
-    } else if (!strcmp(type, "ON_PUBLISH")) {
-        ctx->on_publish = ref;
-        mosquitto_publish_callback_set(ctx->mosq, ctx_on_publish);
-    } else if (!strcmp(type, "ON_MESSAGE")) {
-        ctx->on_message = ref;
-        mosquitto_message_callback_set(ctx->mosq, ctx_on_message);
-    } else if (!strcmp(type, "ON_SUBSCRIBE")) {
-        ctx->on_subscribe = ref;
-        mosquitto_subscribe_callback_set(ctx->mosq, ctx_on_subscribe);
-    } else if (!strcmp(type, "ON_UNSUBSCRIBE")) {
-        ctx->on_unsubscribe = ref;
-        mosquitto_unsubscribe_callback_set(ctx->mosq, ctx_on_unsubscribe);
-    } else if (!strcmp(type, "ON_LOG")) {
-        ctx->on_log = ref;
-        mosquitto_log_callback_set(ctx->mosq, ctx_on_log);
-    } else {
-        luaL_unref(L, LUA_REGISTRYINDEX, ref);
-        luaL_argerror(L, 2, "not a proper callback type");
-    }
-
-    return mosq__pstatus(L, MOSQ_ERR_SUCCESS);
-}
-
-static const struct luaL_Reg methods[] = {
-    {"destroy",         ctx_destroy},
-    {"reinitialise",    ctx_reinitialise},
-    {"will_set",        ctx_will_set},
-    {"will_clear",      ctx_will_clear},
-    {"login_set",       ctx_login_set},
-    {"tls_insecure_set",ctx_tls_insecure_set},
-    {"tls_set",         ctx_tls_set},
-    {"tls_psk_set",     ctx_tls_psk_set},
-    {"tls_opts_set",    ctx_tls_opts_set},
-    {"option",          ctx_option},
-    {"connect",			ctx_connect},
-    {"disconnect",		ctx_disconnect},
-    {"publish",			ctx_publish},
-    {"subscribe",		ctx_subscribe},
-    {"unsubscribe",		ctx_unsubscribe},
-    {"callback_set",    ctx_callback_set},
-    {NULL, NULL}
-};
-
-int luaopen_eco_core_mqtt(lua_State *L)
-{
-    lua_newtable(L);
-
-    lua_pushcfunction(L, mosq_version);
-    lua_setfield(L, -2, "mosq_version");
-
-    eco_new_metatable(L, ECO_MQTT_CTX_MT, methods);
-    lua_pushcclosure(L, mosq_new, 1);
-    lua_setfield(L, -2, "new");
-
-    lua_add_constant(L, "LOG_NONE",	MOSQ_LOG_NONE);
-    lua_add_constant(L, "LOG_INFO",	MOSQ_LOG_INFO);
-    lua_add_constant(L, "LOG_NOTICE", MOSQ_LOG_NOTICE);
-    lua_add_constant(L, "LOG_WARNING", MOSQ_LOG_WARNING);
-    lua_add_constant(L, "LOG_ERROR", MOSQ_LOG_ERR);
-    lua_add_constant(L, "LOG_DEBUG", MOSQ_LOG_DEBUG);
-    lua_add_constant(L, "LOG_ALL", MOSQ_LOG_ALL);
-
-    lua_add_constant(L, "OPT_PROTOCOL_VERSION",MOSQ_OPT_PROTOCOL_VERSION);
-    lua_add_constant(L, "OPT_SSL_CTX", MOSQ_OPT_SSL_CTX);
-    lua_add_constant(L, "OPT_SSL_CTX_WITH_DEFAULTS", MOSQ_OPT_SSL_CTX_WITH_DEFAULTS);
-    lua_add_constant(L, "OPT_RECEIVE_MAXIMUM", MOSQ_OPT_RECEIVE_MAXIMUM);
-    lua_add_constant(L, "OPT_SEND_MAXIMUM", MOSQ_OPT_SEND_MAXIMUM);
-    lua_add_constant(L, "OPT_TLS_KEYFORM", MOSQ_OPT_TLS_KEYFORM);
-    lua_add_constant(L, "OPT_TLS_ENGINE", MOSQ_OPT_TLS_ENGINE);
-    lua_add_constant(L, "OPT_TLS_ENGINE_KPASS_SHA1", MOSQ_OPT_TLS_ENGINE_KPASS_SHA1);
-    lua_add_constant(L, "OPT_TLS_OCSP_REQUIRED", MOSQ_OPT_TLS_OCSP_REQUIRED);
-    lua_add_constant(L, "OPT_TLS_ALPN",	MOSQ_OPT_TLS_ALPN);
-
-    lua_add_constant(L, "PROTOCOL_V31",	MQTT_PROTOCOL_V31);
-    lua_add_constant(L, "PROTOCOL_V311", MQTT_PROTOCOL_V311);
-    lua_add_constant(L, "PROTOCOL_V5", MQTT_PROTOCOL_V5);
-
-    return 1;
-}
diff --git a/mqtt.lua b/mqtt.lua
index 16aae4b..ad59e9e 100644
--- a/mqtt.lua
+++ b/mqtt.lua
@@ -1,123 +1,740 @@
 -- SPDX-License-Identifier: MIT
 -- Author: Jianhui Zhao <zhaojh329@gmail.com>
 
-local mqtt  = require 'eco.core.mqtt'
 local socket = require 'eco.socket'
-local dns = require 'eco.dns'
+local time = require 'eco.time'
+local ssl = require 'eco.ssl'
 
-local M = {}
+local str_char = string.char
+local str_byte = string.byte
+local concat = table.concat
 
-local methods = {}
+local M = {
+    QOS0 = 0,
+    QOS1 = 1,
+    QOS2 = 2,
+    SUBACK_FAILURE = 0x80,
+    CONNACK_ACCEPTED = 0,
+    CONNACK_REFUSED_PROTOCOL_VERSION = 1,
+    CONNACK_REFUSED_IDENTIFIER_REJECTED = 2,
+    CONNACK_REFUSED_SERVER_UNAVAILABLE = 3,
+    CONNACK_REFUSED_BAD_USER_NAME_OR_PASSWORD = 4,
+    CONNACK_REFUSED_NOT_AUTHORIZED = 5
+}
+
+local PKT_CONNECT     = 1
+local PKT_CONNACK     = 2
+local PKT_PUBLISH     = 3
+local PKT_PUBACK      = 4
+local PKT_PUBREC      = 5
+local PKT_PUBREL      = 6
+local PKT_PUBCOMP     = 7
+local PKT_SUBSCRIBE   = 8
+local PKT_SUBACK      = 9
+local PKT_UNSUBSCRIBE = 10
+local PKT_UNSUBACK    = 11
+local PKT_PINGREQ     = 12
+local PKT_DISCONNECT  = 14
+
+local retransmit_interval = 3.0
+local read_timeout = 5.0
 
-function methods:destroy()
-    return self.con:destroy()
+local function check_will_option(will)
+    assert(type(will.topic) == 'string', 'expecting will.topic to be a string')
+    assert(type(will.message) == 'string', 'expecting will.message to be a string')
+    assert(will.retain == nil or type(will.retain) == 'boolean', 'expecting will.retain to be a boolean')
+
+    if will.qos ~= nil then
+        assert(will.qos == M.QOS0 or will.qos == M.QOS1 or will.qos == M.QOS2, 'expecting will.qos to be 0 or 1 or 2')
+    end
 end
 
-function methods:disconnect()
-    return self.con:disconnect()
+local function check_option(name, value)
+    assert(type(name) == 'string')
+
+    if name == 'ipaddr' then
+        assert(value == nil or type(value) == 'string', 'expecting ipaddr to be a string')
+    elseif name == 'port' then
+        assert(value == nil or type(value) == 'number', 'expecting port to be a number')
+    elseif name == 'ssl' then
+        assert(value == nil or type(value) == 'boolean', 'expecting ssl to be a boolean')
+    elseif name == 'ca' then
+        assert(value == nil or type(value) == 'string', 'expecting ca to be a string')
+    elseif name == 'cert' then
+        assert(value == nil or type(value) == 'string', 'expecting cert to be a string')
+    elseif name == 'key' then
+        assert(value == nil or type(value) == 'string', 'expecting key to be a string')
+    elseif name == 'insecure' then
+        assert(value == nil or type(value) == 'boolean', 'expecting insecure to be a boolean')
+    elseif name == 'mark' then
+        assert(value == nil or type(value) == 'number', 'expecting mark to be a number')
+    elseif name == 'device' then
+        assert(value == nil or type(value) == 'string', 'expecting device to be a string')
+    elseif name == 'id' then
+        assert(value == nil or type(value) == 'string', 'expecting id to be a string')
+    elseif name == 'keepalive' then
+        assert(value == nil or type(value) == 'number', 'expecting keepalive to be a number')
+    elseif name == 'clean_session' then
+        assert(value == nil or type(value) == 'boolean', 'expecting clean_session to be a boolean')
+    elseif name == 'username' then
+        assert(value == nil or type(value) == 'string', 'expecting username to be a string')
+    elseif name == 'password' then
+        assert(value == nil or type(value) == 'string', 'expecting password to be a string')
+    elseif name == 'will' then
+        assert(value == nil or type(value) == 'table', 'expecting will to be a table')
+        check_will_option(value)
+    end
 end
 
-function methods:reinitialise(id, clean_session)
-    return self.con:reinitialise(id, clean_session)
+local pkt_methods = {}
+
+function pkt_methods:change_flags(flags)
+    local buf = self.buf
+    local byte = str_byte(buf[1])
+    self.buf[1] = str_char((byte & 0xf0) | flags)
+    return self
 end
 
-function methods:will_set(topic, payload, qos, retain)
-    return self.con:will_set(topic, payload, qos, retain)
+function pkt_methods:add_u16(n)
+    local buf = self.buf
+    buf[#buf + 1] = string.char(n >> 8, n & 0xff)
+    return self
 end
 
-function methods:will_clear()
-    return self.con:will_clear()
+function pkt_methods:add_u8(n)
+    local buf = self.buf
+    buf[#buf + 1] = string.char(n)
+    return self
 end
 
-function methods:login_set(username, password)
-    return self.con:login_set(username, password)
+function pkt_methods:add_string(s)
+    local buf = self.buf
+    buf[#buf + 1] = string.char(#s >> 8, #s & 0xff)
+    buf[#buf + 1] = s
+    return self
 end
 
-function methods:tls_insecure_set(insecure)
-    return self.con:tls_insecure_set(insecure)
+function pkt_methods:add_data(data)
+    local buf = self.buf
+    buf[#buf + 1] = data
+    return self
 end
 
-function methods:tls_set(cafile, capath, certfile, keyfile)
-    return self.con:tls_set(cafile, capath, certfile, keyfile)
+function pkt_methods:data()
+    return concat(self.buf)
 end
 
-function methods:tls_psk_set(psk, identity, ciphers)
-    return self.con:tls_psk_set(psk, identity, ciphers)
+local pkt_metatable = {
+    __index = pkt_methods
+}
+
+local function mqtt_packet(typ, flags, remlen)
+    flags = flags or 0
+    remlen = remlen or 0
+
+    local buf = { str_char(typ << 4 | flags) }
+
+    repeat
+        local byte = remlen % 128
+
+        remlen = remlen // 128
+
+        if remlen > 0 then
+            byte = byte | 128
+        end
+
+        buf[#buf + 1] = str_char(byte)
+    until remlen == 0
+
+    return setmetatable({ buf = buf }, pkt_metatable)
 end
 
-function methods:tls_opts_set(cert_required, tls_version, ciphers)
-    return self.con:tls_psk_set(cert_required, tls_version, ciphers)
+local function get_next_mid(self)
+    self.mid = self.mid + 1
+
+    if self.mid > 0xffff then
+        self.mid = 1
+    end
+
+    return self.mid
 end
 
-function methods:option(option, value)
-    return self.con:option(option, value)
+local function on_event(self, ev, data)
+    local cb = self.handlers[ev]
+    if cb then
+        cb(data, self)
+    end
 end
 
-function methods:publish(topic, payload, qos, retain)
-    return self.con:publish(topic, payload, qos, retain)
+local function send_pkt(self, data)
+    local ok, err = self.sock:send(data)
+    if not ok then
+        if err == 'busy' then
+            time.sleep(0.001)
+            return send_pkt(self, data)
+        end
+        return nil, 'network: ' .. err
+    end
+
+    return ok
 end
 
-function methods:subscribe(topic, qos)
-    return self.con:subscribe(topic, qos)
+local function handle_retransmit(tmr, self)
+    for _, w in pairs(self.wait_for_suback) do
+        send_pkt(self, w.data)
+    end
+
+    for _, w in pairs(self.wait_for_unsuback) do
+        send_pkt(self, w.data)
+    end
+
+    for _, w in pairs(self.wait_for_puback) do
+        send_pkt(self, w.data)
+    end
+
+    for _, w in pairs(self.wait_for_pubrec) do
+        send_pkt(self, w.data)
+    end
+
+    tmr:set(retransmit_interval)
 end
 
-function methods:unsubscribe(topic)
-    return self.con:unsubscribe(topic)
+local max_mult = 128 * 128 * 128
+
+local function read_packet(sock)
+    local byte, err = sock:read(1, read_timeout)
+    if not byte then
+        if err ~= 'timeout' then
+            err = 'network: ' .. err
+        end
+        return nil, err
+    end
+
+    byte = str_byte(byte)
+
+    local typ = byte >> 4
+    local flags = byte & 0xf
+
+    local remlen = 0
+    local mult = 1
+
+    repeat
+        byte, err = sock:read(1, read_timeout)
+        if not byte then
+            return nil, 'network: ' .. err
+        end
+
+        byte = str_byte(byte)
+        remlen = remlen + mult * (byte & 0x7f)
+        mult = mult * 128
+
+        if mult > max_mult then
+            return nil, 'malformed remaining length'
+        end
+    until byte & 0x80 == 0
+
+    local data, err = sock:readfull(remlen, read_timeout)
+    if not data then
+        return nil, 'network: ' .. err
+    end
+
+    return typ, flags, data
 end
 
-function methods:set_callback(typ, func)
-    return self.con:callback_set(typ, function(...)
-        eco.run(func, ...)
-    end)
+local function handler_packet(self)
+    local pt, flags, data = read_packet(self.sock)
+    if not pt then
+        local err = flags
+        if err ~= 'timeout' then
+            return false, err
+        end
+
+        if not self.connected then
+            return false, 'wait CONACK timeout'
+        elseif self.wait_pingresp and time.now() -  self.wait_pingresp >= read_timeout then
+            return false, 'wait PINGRESP timeout'
+        end
+
+        return true
+    end
+
+    self.wait_pingresp = nil
+
+    if not self.connected and pt ~= PKT_CONNACK then
+        return false, 'expecting CONNACK but received ' .. pt
+    end
+
+    if pt == PKT_CONNACK then
+        if self.connected then
+            on_event(self, 'error', 'unexpecting CONNACK received')
+            return true
+        end
+
+        local reasons = {
+            'connection accepted',
+            'connection refused: unacceptable protocol version',
+            'connection refused: identifier rejected',
+            'connection refused: server unavailable',
+            'connection refused: bad user name or password',
+            'connection refused: not authorised'
+        }
+
+        local rc = str_byte(data, 2)
+        local reason = reasons[rc + 1] or ('connection refused: unknown reason code ' .. rc)
+        local session_present = str_byte(data) & 0x01 == 1
+
+        if rc == M.CONNACK_ACCEPTED then
+            local opts = self.opts
+
+            self.connected = true
+
+            self.retransmit_timer:set(retransmit_interval)
+
+            if opts.keepalive > 0 then
+                self.ping_tmr:set(opts.keepalive)
+            end
+        end
+
+        on_event(self, 'conack', { rc = rc, reason = reason, session_present = session_present })
+    elseif pt == PKT_SUBACK then
+        local mid, rc = string.unpack('>I2B', data)
+        local w = self.wait_for_suback[mid]
+        if not w then
+            return true
+        end
+
+        self.wait_for_suback[mid] = nil
+
+        if rc ~= M.QOS0 and rc ~= M.QOS1 and rc ~= M.QOS2 and rc ~= M.SUBACK_FAILURE then
+            on_event(self, 'error', 'SUBACK for topic "' .. w.topic .. '" with invalid return code ' .. rc)
+        else
+            on_event(self, 'suback', { rc = rc, topic = w.topic })
+        end
+    elseif pt == PKT_UNSUBACK then
+        local mid = string.unpack('>I2', data)
+        local w = self.wait_for_unsuback[mid]
+        if not w then
+            return true
+        end
+        self.wait_for_unsuback[mid] = nil
+        on_event(self, 'unsuback', w.topic)
+    elseif pt == PKT_PUBACK then
+        local mid = string.unpack('>I2', data)
+        local w = self.wait_for_puback[mid]
+        if not w then
+            return true
+        end
+        self.wait_for_puback[mid] = nil
+        return true
+    elseif pt == PKT_PUBREC then
+        local mid = string.unpack('>I2', data)
+
+        -- check if this is a duplicate
+        if self.wait_for_pubcomp[mid] then
+            return true
+        end
+
+        local w = self.wait_for_pubrec[mid]
+        if not w then
+            return true
+        end
+        self.wait_for_pubrec[mid] = nil
+
+        data = mqtt_packet(PKT_PUBREL, 0x02, 2):add_u16(mid):data()
+        self.wait_for_pubcomp[mid] = { data = data }
+        return send_pkt(self, data)
+    elseif pt == PKT_PUBCOMP then
+        local mid = string.unpack('>I2', data)
+        local w = self.wait_for_pubcomp[mid]
+        if not w then
+            return true
+        end
+        self.wait_for_pubcomp[mid] = nil
+    elseif pt == PKT_PUBREL then
+        local mid = string.unpack('>I2', data)
+        local w = self.wait_for_pubrel[mid]
+        if not w then
+            return true
+        end
+        self.wait_for_pubrel[mid] = nil
+        data = mqtt_packet(PKT_PUBCOMP, 0x02, 2):add_u16(mid):data()
+        return send_pkt(self, data)
+    elseif pt == PKT_PUBLISH then
+        local topic_len = string.unpack('>I2', data)
+        local topic = data:sub(3, 3 + topic_len - 1)
+        local dup = (flags >> 3) & 0x1 == 0x1
+        local qos = (flags >> 1) & 0x3
+        local retain = flags & 0x1 == 0x1
+
+        data = data:sub(3 + topic_len)
+
+        if qos > 0 then
+            local mid = string.unpack('>I2', data)
+
+            if qos == M.QOS1 then
+                local ok, err = send_pkt(self, mqtt_packet(PKT_PUBACK, 0x02, 2):add_u16(mid):data())
+                if not ok then
+                    return false, err
+                end
+            elseif qos == M.QOS2 then
+                -- check if this is a duplicate
+                local w = self.wait_for_pubrel[mid]
+                if w then
+                    return true
+                else
+                    local pkt = mqtt_packet(PKT_PUBREC, 0x02, 2):add_u16(mid)
+                    self.wait_for_pubrel[mid] = { data = pkt:data() }
+                    local ok, err = send_pkt(self, pkt:data())
+                    if not ok then
+                        return false, err
+                    end
+                end
+            else
+                on_event(self, 'error', 'invalid PUBLISH received with unknown qos number ' .. qos)
+                return true
+            end
+
+            data = data:sub(3)
+        end
+
+        on_event(self, 'publish', { topic = topic, payload = data, qos = qos, dup = dup, retain = retain })
+    end
+
+    return true
+end
+
+local function mqtt_connect(self)
+    local opts = self.opts
+    local ipaddr = opts.ipaddr or '127.0.0.1'
+    local sock, err
+
+    if opts.ssl then
+        sock, err = ssl.connect(ipaddr, opts.port or 8883, opts)
+    else
+        sock, err = socket.connect_tcp(ipaddr, opts.port or 1883, opts)
+    end
+    if not sock then
+        return false, 'network: ' .. err
+    end
+
+    opts.id = opts.id or string.format('lua-eco-%07x', math.random(1, 0xfffffff))
+    opts.keepalive = opts.keepalive or 30.0
+
+    local remlen = 10 + #opts.id + 2
+    local will = opts.will
+    local flags = 0
+
+    if opts.clean_session then
+        flags = flags | 1 << 1
+    end
+
+    if will then
+        remlen = remlen + #will.topic + 2
+        remlen = remlen + #will.message + 2
+
+        flags = flags | 1 << 2
+
+        if will.qos then
+            flags = flags | (will.qos & 0x3) << 3
+        end
+
+        if will.retain then
+            flags = flags | 1 << 5
+        end
+    end
+
+    if opts.username then
+        remlen = remlen + #opts.username + 2
+        flags = flags | 1 << 7
+
+        if opts.password then
+            remlen = remlen + #opts.password + 2
+            flags = flags | 1 << 6
+        end
+    end
+
+    local pkt = mqtt_packet(PKT_CONNECT, 0, remlen)
+
+    -- Protocol Level: 3.1.1
+    pkt:add_string('MQTT')
+    pkt:add_u8(0x04)
+
+    pkt:add_u8(flags)
+    pkt:add_u16(opts.keepalive)
+    pkt:add_string(opts.id)
+
+    if will then
+        pkt:add_string(will.topic)
+        pkt:add_string(will.message)
+    end
+
+    if opts.username then
+        pkt:add_string(opts.username)
+
+        if opts.password then
+            pkt:add_string(opts.password)
+        end
+    end
+
+    self.sock = sock
+
+    return send_pkt(self, pkt:data())
 end
 
-local function try_connect(con, address, port, keepalive)
-    local __con = con.con
+local methods = {}
+
+function methods:publish(topic, payload, qos, retain)
+    assert(type(topic) == 'string')
+    assert(type(payload) == 'string')
+    assert(retain == nil or type(retain) == 'boolean')
+
+    if not self.connected then
+        return false, 'unconnected'
+    end
+
+    if qos ~= nil then
+        assert(qos == M.QOS0 or qos == M.QOS1 or qos == M.QOS2)
+    end
+
+    local remlen = 2 + #topic + #payload
+
+    qos = qos or M.QOS0
+
+    if qos > 0 then
+        remlen = remlen + 2
+    end
+
+    local flags = qos << 1
+
+    if retain then
+        flags = flags | 0x1
+    end
+
+    local pkt = mqtt_packet(PKT_PUBLISH, flags, remlen)
+
+    pkt:add_string(topic)
+
+    local mid = 0
+
+    if qos > 0 then
+        mid = get_next_mid(self)
+        pkt:add_u16(mid)
+    end
+
+    pkt:add_data(payload)
+
+    local data = pkt:data()
+
+    if qos > 0 then
+        -- set dup flag
+        pkt:change_flags(flags | 1 << 3)
+
+        if qos == M.QOS1 then
+            self.wait_for_puback[mid] = { data = pkt:data() }
+        else
+            self.wait_for_pubrec[mid] = { data = pkt:data() }
+        end
+    end
+
+    local ok, err = send_pkt(self, data)
+    if not ok then
+        if qos > 0 then
+            if qos == M.QOS1 then
+                self.wait_for_puback[mid] = nil
+            else
+                self.wait_for_pubrec[mid] = nil
+            end
+        end
 
-    local s, err = socket.connect_tcp(address, port)
-    if not s then
         return false, err
     end
 
-    s:close()
+    return true
+end
+
+function methods:subscribe(topic, qos)
+    assert(type(topic) == 'string' and #topic > 0)
+    assert(qos == nil or qos == M.QOS0 or qos == M.QOS1 or qos == M.QOS2)
+
+    if not self.connected then
+        return false, 'unconnected'
+    end
+
+    local remlen = 2 + 2 + #topic + 1
 
-    local ok
-    ok, err = __con:connect(address, port, keepalive)
+    local mid = get_next_mid(self)
+    local pkt = mqtt_packet(PKT_SUBSCRIBE, 0x02, remlen):add_u16(mid)
+
+    pkt:add_string(topic)
+    pkt:add_u8(qos or M.QOS0)
+
+    local data = pkt:data()
+
+    self.wait_for_suback[mid] = {
+        topic = topic,
+        data = data
+    }
+
+    local ok, err = send_pkt(self, data)
     if not ok then
+        self.wait_for_suback[mid] = nil
         return false, err
     end
 
     return true
 end
 
-function methods:connect(host, port, keepalive)
-    local answers, err = dns.query(host or 'localhost')
-    if not answers then
+function methods:unsubscribe(topic)
+    assert(type(topic) == 'string' and #topic > 0)
+
+    if not self.connected then
+        return false, 'unconnected'
+    end
+
+    local remlen = 2 + 2 + #topic
+
+    local mid = get_next_mid(self)
+    local pkt = mqtt_packet(PKT_UNSUBSCRIBE, 0x02, remlen):add_u16(mid)
+
+    pkt:add_string(topic)
+
+    local data = pkt:data()
+
+    self.wait_for_unsuback[mid] = {
+        topic = topic,
+        data = data
+    }
+
+    local ok, err = send_pkt(self, data)
+    if not ok then
+        self.wait_for_unsuback[mid] = nil
         return false, err
     end
 
-    local ok
+    return true
+end
 
-    for _, a in ipairs(answers) do
-        if a.type == dns.TYPE_A or a.type == dns.TYPE_AAAA then
-            ok, err = try_connect(self, a.address, port, keepalive)
-            if ok then
-                return true
-            end
-        end
+function methods:disconnect()
+    if not self.connected then
+        return true
+    end
+
+    local pkt = mqtt_packet(PKT_DISCONNECT)
+    return send_pkt(self, pkt:data())
+end
+
+-- Add functions as handlers of given events
+-- client:on(event, function)
+-- client:on({ event1 = func1, event2 = func2 })
+function methods:on(...)
+    local nargs = select('#', ...)
+    local events
+
+    if nargs == 2 then
+        events = { [select(1, ...)] = select(2, ...) }
+    elseif nargs == 1 then
+        events = select(1, ...)
+    else
+        error('invalid args: expected only one or two arguments')
+    end
+
+    for event, func in pairs(events) do
+        assert(type(event) == 'string', 'expecting event to be a string')
+        assert(type(func) == 'function', 'expecting func to be a function')
+        self.handlers[event] = func
+    end
+end
+
+function methods:set(name, value)
+    local opts = self.opts
+    check_option(name, value)
+    opts[name] = value
+end
+
+-- Start handling events until the network connection is closed
+function methods:run()
+    local ok, err = mqtt_connect(self)
+    if not ok then
+        on_event(self, 'error', err)
+        return
     end
 
-    return false, err
+    repeat
+        ok, err = handler_packet(self)
+    until not ok
+
+    on_event(self, 'error', err)
+
+    self.retransmit_timer:cancel()
+    self.ping_tmr:cancel()
+    self.sock:close()
+    self.wait_pingresp = nil
+    self.connected = false
 end
 
 local metatable = {
     __index = methods
 }
 
-function M.new(id, clean_session)
-    local con = mqtt.new(id, clean_session)
+--[[
+    opts: A table contains some options:
+        ipaddr: Network address to connect to. Defaults to '127.0.0.1'.
+        port: Network port to connect to. Defaults to 1883 for plain MQTT and 8883 for MQTT over TLS.
+        ssl: A boolean, indicates connecting with SSL/TLS.
+        ca: CA certificate for authentication if required by server.
+        cert: Client certificate for authentication, if required by server.
+        key: Client private key for authentication, if required by server.
+        insecure: A boolean, SSL connecting with insecure.
+        mark: A number used to set SO_MARK to socket.
+        device: A string used to set SO_BINDTODEVICE to socket.
+
+        id: client id, will be randomly generated if not provided.
+        keepalive: Keep alive in sesonds, defaults 30.
+        clean_session: A boolean
+        will: A table contains some options for will:
+            topic: The topic name of client's will message.
+            message: The message to be published when the client disconnected.
+            qos: The qos used to published will message.
+            retain: Retain will message.
+        username: The username to be used to connect to the broker with.
+        password: The password to be used to connect to the broker with.
+--]]
+function M.new(opts)
+    opts = opts or {}
+
+    assert(type(opts) == 'table', 'expecting opts to be a table')
+
+    for name, value in pairs(opts) do
+        check_option(name, value)
+        opts[name] = value
+    end
+
+    local o = {
+        mid = 0,
+        opts = opts,
+        handlers = {},
+        wait_for_suback = {},
+        wait_for_unsuback = {},
+        wait_for_puback = {},
+        wait_for_pubrec = {},
+        wait_for_pubrel = {},
+        wait_for_pubcomp = {}
+    }
+
+    o.retransmit_timer = time.timer(handle_retransmit, o)
+
+    o.ping_tmr = time.timer(function(tmr)
+        o.wait_pingresp = time.now()
+
+        local ok, err = send_pkt(o, mqtt_packet(PKT_PINGREQ):data())
+        if not ok then
+            on_event(o, 'error', err)
+        else
+            tmr:set(o.opts.keepalive)
+        end
+    end)
 
-    return setmetatable({ con = con }, metatable)
+    return setmetatable(o, metatable)
 end
 
-return setmetatable(M, { __index = mqtt })
+return M
diff --git a/tests/mqtt_pub.lua b/tests/mqtt_pub.lua
index 6fe0ada..0c17536 100755
--- a/tests/mqtt_pub.lua
+++ b/tests/mqtt_pub.lua
@@ -3,34 +3,51 @@
 local mqtt = require 'eco.mqtt'
 local time = require 'eco.time'
 
-local con = mqtt.new('eco-' .. os.time())
+local client = mqtt.new({ ipaddr = '127.0.0.1' })
 
-local disconnected = false
+local function publish_loop()
+    local data = {}
 
-con:set_callback('ON_CONNECT', function(success, rc, str)
-    print('ON_CONNECT:', success, rc, str)
+    -- build 1MB data
+    for _ = 1, 1024 * 1024 do
+        data[#data + 1] = 'x'
+    end
 
-    eco.run(function()
-        local i = 0
-        while not disconnected do
-            print('pub', i)
-            con:publish('eco', 'hello ' .. i)
-            time.sleep(0.0001)
-            i = i + 1
+    data = table.concat(data)
+
+    local i = 0
+
+    while true do
+        local n = string.format('%010d', i)
+
+        print('pub', n)
+
+        local ok, err = client:publish('eco', n .. data, mqtt.QOS2)
+        if not ok then
+            print('publish:', err)
+            break
         end
-    end)
-end)
 
-con:set_callback('ON_DISCONNECT', function(success, rc, str)
-    print('ON_DISCONNECT:', success, rc, str)
-    disconnected = true
-end)
+        time.sleep(0.001)
 
-local ok, err = con:connect('localhost', 1883)
-if not ok then
-    error(err)
+        i = i + 1
+    end
 end
 
-while true do
-    time.sleep(1)
-end
+client:on({
+    conack = function(ack)
+        print('conack:', ack.rc, ack.reason)
+
+        if ack.rc ~= mqtt.CONNACK_ACCEPTED then
+            return
+        end
+
+        eco.run(publish_loop)
+    end,
+
+    error = function(err)
+        print('error:', err)
+    end
+})
+
+client:run()
diff --git a/tests/mqtt_sub.lua b/tests/mqtt_sub.lua
index 99fb01b..a9e40bd 100755
--- a/tests/mqtt_sub.lua
+++ b/tests/mqtt_sub.lua
@@ -1,29 +1,27 @@
 #!/usr/bin/env eco
 
 local mqtt = require 'eco.mqtt'
-local time = require 'eco.time'
 
-local con = mqtt.new('eco-' .. os.time())
+local client = mqtt.new({ ipaddr = '127.0.0.1' })
 
-con:set_callback('ON_CONNECT', function(success, rc, str)
-    print('ON_CONNECT:', success, rc, str)
+client:on({
+    conack = function(ack)
+        print('conack:', ack.rc, ack.reason)
 
-    con:subscribe('eco', 2)
-end)
+        if ack.rc ~= mqtt.CONNACK_ACCEPTED then
+            return
+        end
 
-con:set_callback('ON_DISCONNECT', function(success, rc, str)
-    print('ON_DISCONNECT:', success, rc, str)
-end)
+        client:subscribe('eco', mqtt.QOS2)
+    end,
 
-con:set_callback('ON_MESSAGE', function(mid, topic, payload, qos, retain)
-    print('ON_MESSAGE:', mid, topic, payload, qos, retain)
-end)
+    publish = function(msg)
+        print('message:', msg.payload:match('%d+'))
+    end,
 
-local ok, err = con:connect('localhost', 1883)
-if not ok then
-    error(err)
-end
+    error = function(err)
+        print('error:', err)
+    end
+})
 
-while true do
-    time.sleep(1)
-end
+client:run()
-- 
2.34.1

