Index: b/logtail/logtail.go
===================================================================
--- a/logtail/logtail.go	2024-05-06 20:52:31.648249569 -0700
+++ b/logtail/logtail.go	2024-05-06 20:53:23.059512824 -0700
@@ -737,33 +737,34 @@ var obscureIPs = envknob.RegisterBool("T
 //
 // This is intended as an interface for the stdlib "log" package.
 func (l *Logger) Write(buf []byte) (int, error) {
-	if len(buf) == 0 {
-		return 0, nil
-	}
-	inLen := len(buf) // length as provided to us, before modifications to downstream writers
-
-	level, buf := parseAndRemoveLogLevel(buf)
-	if l.stderr != nil && l.stderr != io.Discard && int64(level) <= atomic.LoadInt64(&l.stderrLevel) {
-		if buf[len(buf)-1] == '\n' {
-			l.stderr.Write(buf)
-		} else {
-			// The log package always line-terminates logs,
-			// so this is an uncommon path.
-			withNL := append(buf[:len(buf):len(buf)], '\n')
-			l.stderr.Write(withNL)
-		}
-	}
-
-	if obscureIPs() {
-		buf = redactIPs(buf)
-	}
-
-	l.writeLock.Lock()
-	defer l.writeLock.Unlock()
-
-	b := l.encodeLocked(buf, level)
-	_, err := l.sendLocked(b)
-	return inLen, err
+	return 0, nil
+	//if len(buf) == 0 {
+	//	return 0, nil
+	//}
+	//inLen := len(buf) // length as provided to us, before modifications to downstream writers
+	//
+	//level, buf := parseAndRemoveLogLevel(buf)
+	//if l.stderr != nil && l.stderr != io.Discard && int64(level) <= atomic.LoadInt64(&l.stderrLevel) {
+	//	if buf[len(buf)-1] == '\n' {
+	//		l.stderr.Write(buf)
+	//	} else {
+	//		// The log package always line-terminates logs,
+	//		// so this is an uncommon path.
+	//		withNL := append(buf[:len(buf):len(buf)], '\n')
+	//		l.stderr.Write(withNL)
+	//	}
+	//}
+	//
+	//if obscureIPs() {
+	//	buf = redactIPs(buf)
+	//}
+	//
+	//l.writeLock.Lock()
+	//defer l.writeLock.Unlock()
+	//
+	//b := l.encodeLocked(buf, level)
+	//_, err := l.sendLocked(b)
+	//return inLen, err
 }
 
 var (
